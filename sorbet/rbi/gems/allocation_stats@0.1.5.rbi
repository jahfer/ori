# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `allocation_stats` gem.
# Please instead update this file by running `bin/tapioca gem allocation_stats`.


# Container for an aggregation of object allocation data. Pass a block to
# {#trace AllocationStats.new.trace}. Then use the AllocationStats object's public
# interface to dig into the data and discover useful information.
#
# source://allocation_stats//lib/allocation_stats/allocation.rb#6
class AllocationStats
  # @return [AllocationStats] a new instance of AllocationStats
  #
  # source://allocation_stats//lib/allocation_stats.rb#41
  def initialize(burn: T.unsafe(nil)); end

  # Proxy for the @new_allocations array that allows for individual filtering,
  # sorting, and grouping of the Allocation objects.
  #
  # source://allocation_stats//lib/allocation_stats.rb#131
  def allocations(alias_paths: T.unsafe(nil)); end

  # burn count for block tracing. Defaults to 0. When called with a block,
  # #trace will yield the block @burn-times before actually tracing the object
  # allocations. This offers the benefit of pre-memoizing objects, and loading
  # any required Ruby files before tracing.
  #
  # @return [Fixnum]
  #
  # source://allocation_stats//lib/allocation_stats.rb#28
  def burn; end

  # burn count for block tracing. Defaults to 0. When called with a block,
  # #trace will yield the block @burn-times before actually tracing the object
  # allocations. This offers the benefit of pre-memoizing objects, and loading
  # any required Ruby files before tracing.
  #
  # @return [Fixnum]
  #
  # source://allocation_stats//lib/allocation_stats.rb#28
  def burn=(_arg0); end

  # source://allocation_stats//lib/allocation_stats.rb#104
  def collect_new_allocations; end

  # Returns the value of attribute gc_profiler_report.
  #
  # source://allocation_stats//lib/allocation_stats.rb#30
  def gc_profiler_report; end

  # Sets the attribute gc_profiler_report
  #
  # @param value the value to set the attribute gc_profiler_report to.
  #
  # source://allocation_stats//lib/allocation_stats.rb#30
  def gc_profiler_report=(_arg0); end

  # Inspect @new_allocations, the canonical array of {Allocation} objects.
  #
  # source://allocation_stats//lib/allocation_stats.rb#125
  def inspect; end

  # allocation data for all new objects that were allocated
  # during the {#initialize} block. It is better to use {#allocations}, which
  # returns an {AllocationsProxy}, which has a much more convenient,
  # domain-specific API for filtering, sorting, and grouping {Allocation}
  # objects, than this plain Array object.
  #
  # @return [Array]
  #
  # source://allocation_stats//lib/allocation_stats.rb#39
  def new_allocations; end

  # Begin tracing object allocations. Tracing must be stopped with
  # AllocationStats#stop. Garbage collection is disabled while tracing is
  # enabled.
  #
  # source://allocation_stats//lib/allocation_stats.rb#88
  def start; end

  # Stop tracing object allocations that was started with AllocationStats#start.
  #
  # source://allocation_stats//lib/allocation_stats.rb#117
  def stop; end

  # source://allocation_stats//lib/allocation_stats.rb#53
  def trace(&block); end

  # source://allocation_stats//lib/allocation_stats.rb#61
  def trace_block; end

  private

  # source://allocation_stats//lib/allocation_stats.rb#135
  def profile_and_start_gc; end

  class << self
    # Add a Hash of allocation groups (derived from an
    # `AllocationStats.allocations...group_by(...)`) to the top allocation sites
    # (file/line/class groups).
    #
    # @param allocations [Hash]
    # @param location [String] the RSpec spec location that was being executed
    #   when the allocations occurred
    # @param limit [Fixnum] size of the top sites Array
    #
    # source://allocation_stats//lib/allocation_stats/trace_rspec.rb#72
    def add_to_top_sites(allocations, location, limit = T.unsafe(nil)); end

    # Read the sorted list of the top "sites", that is, top file/line/class
    # groups, encountered while tracing RSpec.
    #
    # @api private
    #
    # source://allocation_stats//lib/allocation_stats/trace_rspec.rb#52
    def top_sites; end

    # Write to the sorted list of the top "sites", that is, top file/line/class
    # groups, encountered while tracing RSpec.
    #
    # @api private
    #
    # source://allocation_stats//lib/allocation_stats/trace_rspec.rb#60
    def top_sites=(value); end

    # Textual String representing the sorted list of the top allocation sites.
    # For each site, this String includes the number of allocations, the class,
    # the sourcefile, the sourceline, and the location of the RSpec spec.
    #
    # @api private
    #
    # source://allocation_stats//lib/allocation_stats/trace_rspec.rb#105
    def top_sites_text; end

    # source://allocation_stats//lib/allocation_stats.rb#48
    def trace(&block); end

    # source://allocation_stats//lib/allocation_stats/trace_rspec.rb#5
    def trace_rspec; end
  end
end

# Information about an individual allocation is captured in this class.
#
# source://allocation_stats//lib/allocation_stats/allocation.rb#8
class AllocationStats::Allocation
  # @return [Allocation] a new instance of Allocation
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#41
  def initialize(object); end

  # Convert into a JSON string, which can be used in rack-allocation_stats's
  # interactive mode.
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#124
  def as_json; end

  # the classpath of where the object was allocated
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#27
  def class_path; end

  # Returns class name, plus, for Arrays, extended information. When all of
  # the elements of the Array are instances of a total of three or fewer
  # classes, then those classes are listed in brackets. For example:
  #
  # @example Array with only Fixnum and Bignum elements
  #   allocation.class_plus  #=> "Array<Fixnum,Bignum>"
  # @example Array with elements of class A, B, C, and D
  #   allocation.class_plus  #=> "Array"
  # @example String (not an Array)
  #   allocation.class_plus  #=> "String"
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#95
  def class_plus; end

  # the sourcefile where the object was allocated
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#51
  def file; end

  # Override Rubygems' Kernel#gem
  #
  # @return [String] the name of the Rubygem where this allocation occurred.
  # @return [nil] if this allocation did not occur in a Rubygem.
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#113
  def gem; end

  # the line in the sourcefile where the object was allocated
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#39
  def line; end

  # the memsize of the object which was allocated
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#23
  def memsize; end

  # the memsize of the object which was allocated
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#23
  def memsize=(_arg0); end

  # the method ID of where the object was allocated
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#31
  def method_id; end

  # the actual object that was allocated
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#35
  def object; end

  # Either the full source file (via `@sourcefile`), or the aliased source
  # file, via {#sourcefile_alias}
  #
  # @param alias_path [TrueClass] whether or not to alias the path
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#81
  def sourcefile(alias_path = T.unsafe(nil)); end

  # If the source file has recognized paths in it, those portions of the full
  # path will be aliased like so:
  #
  # * the present work directory is aliased to "<PWD>"
  # * the Ruby lib directory (where the standard library lies) is aliased to
  #   "<RUBYLIBDIR>"
  # * the Gem directory (where all gems lie) is aliased to "<GEMDIR>"
  #
  # @return the source file, aliased.
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#64
  def sourcefile_alias; end

  # the line in the sourcefile where the object was allocated
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#39
  def sourceline; end

  # Convert into a JSON string, which can be used in rack-allocation_stats's
  # interactive mode.
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#139
  def to_json(*a); end

  private

  # @api private
  # @return either _the one_ class passed in, the two-to-four classes passed
  #   in separated by commas, or `nil` if more than four classes were passed
  #   in.
  #
  # source://allocation_stats//lib/allocation_stats/allocation.rb#148
  def element_classes(classes); end
end

# a list of attributes that Allocation has on itself; inquiries in this
# list should just use Allocation's attributes, rather than the internal
# object's.
#
# source://allocation_stats//lib/allocation_stats/allocation.rb#19
AllocationStats::Allocation::ATTRIBUTES = T.let(T.unsafe(nil), Array)

# a list of helper methods that Allocation provides on top of the object
# that was allocated.
#
# source://allocation_stats//lib/allocation_stats/allocation.rb#14
AllocationStats::Allocation::HELPERS = T.let(T.unsafe(nil), Array)

# a convenience constants
#
# source://allocation_stats//lib/allocation_stats/allocation.rb#10
AllocationStats::Allocation::PWD = T.let(T.unsafe(nil), String)

# AllocationsProxy acts as a proxy for an array of Allocation objects. The
# idea behind this class is merely to provide some domain-specific methods
# for transforming (filtering, sorting, and grouping) allocation information.
# This class uses the Command pattern heavily, in order to build and maintain
# the list of transforms it will ultimately perform, before retrieving the
# transformed collection of Allocations.
#
# Chaining
# ========
#
# Use of the Command pattern and Procs allows for transform-chaining in any
# order. Apply methods such as {#from} and {#group_by} to build the internal
# list of transforms. The transforms will not be applied to the collection of
# Allocations until a call to {#to_a} ({#all}) resolves them.
#
# Filtering Transforms
# --------------------
#
# Methods that filter the collection of Allocations will add a transform to
# an Array, `@wheres`. When the result set is finally retrieved, each where
# is applied serially, so that `@wheres` represents a logical conjunction
# (_"and"_) of of filtering transforms. Presently there is no way to _"or"_
# filtering transforms together with a logical disjunction.
#
# Mapping Transforms
# ------------------
#
# Grouping Transform
# ------------------
#
# Only one method will allow a grouping transform: {#group_by}. Only one
# grouping transform is allowed; subsequent calls to {#group_by} will only
# replace the previous grouping transform.
#
# source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#38
class AllocationStats::AllocationsProxy
  # Instantiate an {AllocationsProxy} with an array of Allocations.
  # {AllocationProxy's} view of `pwd` is set at instantiation.
  #
  # @param allocations [Array<Allocation>] array of Allocation objects
  # @return [AllocationsProxy] a new instance of AllocationsProxy
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#44
  def initialize(allocations, alias_paths: T.unsafe(nil)); end

  # If a value is passed in, @alias_paths will be set to this value, and the
  # AllocationStats object will be returned. If no value is passed in, this
  # will return the @alias_paths.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#77
  def alias_paths(value = T.unsafe(nil)); end

  # Apply all transformations to the contained list of Allocations. This is
  # aliased as `:all`.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#55
  def all; end

  # Select allocation groups which have at least `count` allocations.
  #
  # be selected.
  #
  # @param count [Fixnum] the minimum number of Allocations for each group to
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#102
  def at_least(count); end

  # Map to bytes via {Allocation#memsize #memsize}. This is done in one of
  # two ways:
  #
  # * If the current result set is an Array, then this transform just maps
  #   each Allocation to its `#memsize`.
  # * If the current result set is a Hash (meaning it has been grouped), then
  #   this transform maps each value in the Hash (which is an Array of
  #   Allocations) to the sum of the Allocation `#memsizes` within.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#222
  def bytes; end

  # Select allocations for which the {Allocation#sourcefile sourcefile}
  # includes `pattern`.
  #
  # `#from` can be called multiple times, adding to `@wheres`. See
  # documentation for {AllocationsProxy} for more information about chaining.
  #
  # @param pattern [String] the partial file path to match against, in the
  #   {Allocation#sourcefile Allocation's sourcefile}.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#118
  def from(pattern); end

  # Select allocations for which the {Allocation#sourcefile sourcefile}
  # includes the present working directory.
  #
  # `#from_pwd` can be called multiple times, adding to `@wheres`. See
  # documentation for {AllocationsProxy} for more information about chaining.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#147
  def from_pwd; end

  # Group allocations by one or more attributes, that is, a list of symbols.
  # Commonly, you might want to group allocations by:
  #
  # * :sourcefile, :sourceline, :class
  # * :sourcefile, :method_id, :class
  # * :classpath, :method_id, :class
  #
  # In this case, `:class` is the class of the allocated object (as opposed
  # to `:classpath`, the classpath where the allocation occured).
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#164
  def group_by(*args); end

  # Select allocations for which the {Allocation#sourcefile sourcefile} does
  # not include `pattern`.
  #
  # `#not_from` can be called multiple times, adding to `@wheres`. See
  # documentation for {AllocationsProxy} for more information about chaining.
  #
  # @param pattern [String] the partial file path to match against, in the
  #   {Allocation#sourcefile Allocation's sourcefile}.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#134
  def not_from(pattern); end

  # Sort allocation groups by the number of allocations in each group.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#88
  def sort_by_count; end

  # Sort allocation groups by the number of allocations in each group.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#88
  def sort_by_size; end

  # Apply all transformations to the contained list of Allocations. This is
  # aliased as `:all`.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#55
  def to_a; end

  # Resolve all transformations, and convert the resultant Array to JSON.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#264
  def to_json; end

  # Resolve the AllocationsProxy (by calling {#to_a}) and return tabular
  # information about the Allocations as a String.
  #
  # @param columns [Array<Symbol>] a list of columns to print out
  # @return [String] information about the Allocations, in a tabular format
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#250
  def to_text(columns: T.unsafe(nil)); end

  # Select allocations that match `conditions`.
  #
  # @example select allocations of String objects:
  #   allocations.where(class: String)
  # @param conditions [Hash] pairs of attribute names and values to be matched amongst allocations.
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#184
  def where(conditions); end

  private

  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#200
  def attribute_getters(faux_attributes); end

  # Return tabular information about the grouped Allocations.
  #
  # @private
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#300
  def to_text_from_groups(resolved); end

  # Return tabular information about the un-grouped list of Allocations.
  #
  # @private
  #
  # source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#271
  def to_text_from_plain(resolved, columns: T.unsafe(nil)); end
end

# default columns for the tabular output
#
# source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#239
AllocationStats::AllocationsProxy::DEFAULT_COLUMNS = T.let(T.unsafe(nil), Array)

# columns that should be right-aligned for the tabular output
#
# source://allocation_stats//lib/allocation_stats/allocations_proxy.rb#242
AllocationStats::AllocationsProxy::NUMERIC_COLUMNS = T.let(T.unsafe(nil), Array)

# a convenience constant
#
# source://allocation_stats//lib/allocation_stats.rb#20
AllocationStats::GEMDIR = T.let(T.unsafe(nil), String)

# a convenience constant
#
# source://allocation_stats//lib/allocation_stats.rb#17
AllocationStats::RUBYLIBDIR = T.let(T.unsafe(nil), String)

# source://allocation_stats//lib/allocation_stats/trace_rspec.rb#21
AllocationStats::TRACE_RSPEC_HOOK = T.let(T.unsafe(nil), Proc)

# monkey patch to BasicObject, allowing it to respnd to :class
#
# @private
#
# source://allocation_stats//lib/allocation_stats/core_ext/basic_object.rb#4
class BasicObject
  # monkey patch to BasicObject, allowing it to respnd to :class
  #
  # @private
  #
  # source://allocation_stats//lib/allocation_stats/core_ext/basic_object.rb#8
  def class; end
end
